; a) Write a function to return the n-th element of a list, or NIL if such an element does not exist;

; NthElem(l1l2...lm, n, pos) = 
; = nil , if m = 0
; = l1 , if n = pos
; = NthElem(l2...lm, n, pos + 1) , otherwise

(defun NthElem(l n pos)
  (cond
    ((null l) nil)
    ((= n pos) (car l))
    (t (NthElem (cdr l) n (+ pos 1)))
  )
)

(defun main(l n)
  (NthElem l n 0)
)


; b) Write a function to check whether an atom E is a member of a list which is not necessarily linear.


; checkAtom(l1l2...ln, elem) = 
; = nil , if n = 0
; = true , if l1 is an atom and l1 = elem
; = checkAtom(l1, elem) U checkAtom(l2...ln, elem) , if l1 is a list
; = checkAtom(l2...ln, elem) , otherwise


(defun checkAtom(l elem)
  (cond
    ((null l) nil)
    ((and (atom (car l)) (equal (car l) elem)) T)
    ((listp (car l)) (or (checkAtom (car l) elem) (checkAtom (cdr l) elem))) 
    (T (checkAtom (cdr l) elem))
  )
)


; c) Write a function to determine the list of all sublists of a given list, on any level.
; A sublist is either the list itself, or any element that is a list, at any level. Example:
; (1 2 (3 (4 5) (6 7)) 8 (9 10)) => 5 sublists :
; ( (1 2 (3 (4 5) (6 7)) 8 (9 10)) (3 (4 5) (6 7)) (4 5) (6 7) (9 10) )


; 

(defun allSublists (l)
  (cond
    ((atom l) nil)
    (T (apply 'append (list l) (mapcar 'allSublists l)))
  )
)


; d) Write a function to transform a linear list into a set.

; transformSet(l1l2...ln) = 
; = nil , if n = 0
; = {l1} U transformSet(removeApparences(l2...ln, l1)) , otherwise

(defun transformSet(l)
  (cond
    ((null l) nil)
    (t (cons (car l) (transformSet (removeApparences (cdr l) (car l)))))
  )
)


; removeApparences(l1l2...ln, elem) = 
; = nil , if n = 0
; = removeApparences(l2...ln, elem) , if l1 = elem
; = {l1} U removeApparences(l2...ln, elem) , otherwise

(defun removeApparences(l e)
  (cond 
    ((null l) nil)
    ((= (car l) e) (removeApparences (cdr l) e))
    (t (cons (car l) (removeApparences (cdr l) e)))
  )
)





//////////////////////////////////////2



;a) Write a function to return the dot product of two vectors. https://en.wikipedia.org/wiki/Dot_product 

; dotProduct(l1l2...ln, k1k2...km) = 
; = 0 , if n = 0
; = l1*l2 + dotProduct(l2...ln, k2...km) , otherwise

(defun dotProduct(l k)
  (cond
    ((null l) 0)
    (t (+ (* (car l) (car k)) (dotProduct (cdr l) (cdr k))))
  )
)


;b) Write a function to return the depth of a list. Example: the depth of a linear list is 1. 

; myMax(a, b) = 
; = a , if a > b
; = b ,  otherwise


(defun myMax (a b)
  (cond
    ((> a b) a)
    (t b)
  )
)


; findDepth(l1l2...ln, c) = 
; = c , if n = 0
; = myMax(findDepth(l1,c+1), findDepth(l2...ln, c)) , if l1 is a list
; = findDepth(l2...ln, c) , otherwise


(defun findDepth (l c)
  (cond
    ((null l) c)
    ((listp (car l)) (myMax (findDepth (car l) (+ c 1)) (findDepth (cdr l) c)))
    (t (findDepth (cdr l) c))
  )
)

; main(l1l2...ln) = 
; = findDepth(l1l2...ln, 1)

(defun main(l)
  (cond
    (t (findDepth l 1))
  )
)


; c) Write a function to sort a linear list without keeping the double values.c) 

; insert(l1l2...ln, elem) =
; = list(elem) , if n = 0
; = l1l2...ln , if l1 = elem
; = {elem} U l1l2...ln, if elem < l1
; = {l1} U insert(l2...ln, elem)

(defun insert (l e)
  (cond
    ((null l) (list e))
    ((= (car l) e) l)
    ((< e (car l)) (cons e l))
    (t (cons (car l) (insert (cdr l) e)))
  )
)

; sortare(l1l2...ln) = 
; = nil , if n = 0
; = insert(sortare(l2...ln), l1) , otherwise

(defun sortare (l)
  (cond
    ((null l) nil)
    (t (insert (sortare (cdr l)) (car l)))
  )
)


; d) Write a function to return the intersection of two sets.

; contains(elem, l1l2...ln) = 
; = NIL, if n = 0
; = true, if l1 = elem
; = contains(elem, l2...ln), otherwise


(defun contains(e l)
  (cond
    ((null l) nil)
    ((equal (car l) e) t)
    (t (contains e (cdr l)))
  )
)


; intersection(l1l2...ln, p1p2...pm) = 
; = NIL , if n = 0
; = {l1} U intersection(l2...ln, p1p2...pm) , if contains(l1, p1p2...pm) is true
; = intersection(l2...ln, p1p2...pm) , otherwise


(defun intersection_(l p)
  (cond
    ((null l) NIL)
    ((contains (car l) p) (cons (car l) (intersection_ (cdr l) p)))
    (t (intersection_ (cdr l) p))
  )
)





////////////////////////////////////3



; a) Write a function that inserts in a linear list a given atom A after the 2nd, 4th, 6th, ... element.


; insertElem(l1l2...ln, elem, pos) = 
; = NIL, if n = 0
; = {l1} U {elem} U insertElem(l2...ln, elem, pos + 1) , if pos % 2 = 0
; = {l1} U insertElem(l2...ln, elem, pos + 1) , otherwise


(defun insertElem(l e pos)
  (cond
    ((null l) nil)
    ((equal (mod pos 2) 0) (cons (car l) (cons e (insertElem (cdr l) e (+ 1 pos)))))
    (t (cons (car l) (insertElem (cdr l) e (+ 1 pos))))
  )
)

(defun mainA(l e)
  (insertElem l e 1)
)


; b) Write a function to get from a given list the list of all atoms, on any
; level, but reverse order. Example:
; (((A B) C) (D E)) ==> (E D C B A)


; myAppend(l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = {l1} U myAppend(l2...ln, p1p2...pm) , otherwise


(defun myAppend(l1 l2)
  (cond
    ((null l1) l2)
    (t (cons (car l1) (myAppend (cdr l1) l2)))
  )
)


; getAllAtoms(l1l2...ln) = 
; = NIL , if n = 0
; = myAppend(getAllAtoms(l2...ln), getAllAtoms(l1)) , if l1 is a list
; = myAppend(getAllAtoms(l2...ln), list(l1)) , otherwise

(defun getAllAtoms (l)
  (cond
    ((null l) nil)
    ((listp (car l)) (myAppend (getAllAtoms (cdr l)) (getAllAtoms (car l))))
    (t (myAppend (getAllAtoms (cdr l)) (list (car l))))
  )
)    


;c) Write a function that returns the greatest common divisor of all numbers in a nonlinear list.

;myGCD(a, b) =
; = a , if b is not a number
; = b , if a is not a number
; = a , if b = 0
; = myGCD(b, a%b) , otherwise


(defun myGCD(a b)
  (cond
    ((not (numberp a)) b)
    ((not (numberp b)) a)
    ((= 0 b) a)
    (t (myGCD b (mod a b)))
  )
)

;The following function will return NIL if there is no number and True otherwise
; lookForNumbers(l1l2...ln) = 
; = NIL , if n = 0
; = lookForNumbers(l1) or lookForNumbers(l2...ln) , if l1 is a list
; = true , if l1 is a number
; = lookForNumbers(l2...ln) , otherwise

(defun lookForNumbers(l)
  (cond
    ((null l) nil)
    ((listp (car l)) (or (lookForNumbers (car l)) (lookForNumbers (cdr l))))
    ((numberp (car l)) T)
    (t (lookForNumbers (cdr l)))
  )
)

; gcdForAllNumbers(l1l2...ln) = 
; = l1 , if n = 1
; = myGCD(gcdForAllNumbers(l1), gcdForAllNumbers(l2...ln)) , if l1 is a list
; = myGCD(l1, gcdForAllNumbers(l2...ln)) , otherwise


(defun gcdForAllNumbers(l)
  (cond
    ((null (cdr l)) (car l))
    ((listp (car l)) (myGCD (gcdForAllNumbers (car l)) (gcdForAllNumbers (cdr l))))
    (t (myGCD (car l) (gcdForAllNumbers (cdr l))))
  )
)

;If we don't have any numbers in the list we simply return 1
;Otherwise we go look for the gcd
(defun main(l)
  (cond
    ((lookForNumbers l) (gcdForAllNumbers l))
    (t 1)
  )
)


;d) Write a function that determines the number of occurrences of a given atom in a nonlinear list.

; nrOfOccurrences(l1l2...ln, c, elem) = 
; = c , if n = 0
; = nrOfOccurences(l1, 0, elem) + nrOfOccurences(l2...ln, c, elem) , if l1 is a list
; = nrOfOccurences(l2...ln, c + 1, elem) , if l1 = elem
; = nrOfOccurences(l2...ln, c, elem) , otherwise


(defun nrOfOccurences(l c elem)
  (cond
    ((null l) c)
    ((listp (car l)) (+ (nrOfOccurences (car l) 0 elem) (nrOfOccurences (cdr l) c elem)))
    ((equal (car l) elem) (nrOfOccurences (cdr l) (+ 1 c) elem))
    (t (nrOfOccurences (cdr l) c elem))
  )
)


(defun mainD(l elem)
  (nrOfOccurences l 0 elem)
)



////////////////////////////////4



;a) Write a function to return the sum of two vectors.

; myAppend(l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = {l1} U myAppend(l2...ln, p1p2...pm), otherwise


(defun myAppend (l1 l2)
  (cond
    ((null l1) l2)
    (t (cons (car l1) (myAppend (cdr l1) l2)))
  )
)

; myReverse(l1l2...ln) = 
; = NIL , if n = 0
; = myAppend(myReverse(l2...ln), myReverse(l1)) , if l1 is a list
; = myAppend(myReverse(l2...ln), list(l1)) , otherwise

(defun myReverse (l)
  (cond
    ((null l) nil)
    ((listp (car l)) (myAppend (myReverse (cdr l)) (list(myReverse (car l)))))
    (t (myAppend (myReverse (cdr l)) (list (car l))))
  )
)


; sumVectors (l1l2...ln, p1p2...pm) = 
; = p1p2...pm , if n = 0 
; = {l1 + p1} U sumVectors(l2...ln, p2...pm), otherwise

(defun sumVectors (v1 v2)
  (cond
    ((null v1) v2)
    (t (cons (+ (car v1) (car v2)) (sumVectors (cdr v1) (cdr v2))))
  )
)


; b) Write a function to get from a given list the list of all atoms, on any
;  level, but on the same order. Example:
;  (((A B) C) (D E)) ==> (A B C D E)


; getAllAtoms(l1l2...ln) = 
; = NIL , if n = 0
; = myAppend(getAllAtoms(l1), getAllAtoms(l2...ln)) , if l1 is a list
; = myAppend((list(l1), getAllAtoms(l2...ln)) , otherwise

(defun getAllAtoms (l)
  (cond
    ((null l) nil)
    ((listp (car l)) (myAppend (getAllAtoms(car l)) (getAllAtoms(cdr l))))
    (t (myAppend (list (car l)) (getAllAtoms(cdr l))))
  )
)


;c) Write a function that, with a list given as parameter, inverts only continuous
;   sequences of atoms. Example:
;   (a b c (d (e f) g h i)) ==> (c b a (d (f e) i h g)


; invertCont (l1l2...ln, aux) = 
; = aux , if n = 0
; = myAppend(aux, myAppend(list(invertCont(l1, NIL)), invertCont(l2...ln, NIL))) , if l1 is a list
; = invertCont(l2...ln, myAppend(list(l1), aux)) , otherwise


(defun invertCont (l aux)
  (cond
    ((null l) aux)
    ((listp (car l)) (myAppend aux (myAppend (list (invertCont (car l) nil)) (invertCont (cdr l) nil))))
    (t (invertCont (cdr l) (myAppend (list (car l)) aux)))
  )
)


;d) Write a list to return the maximum value of the numerical atoms from a list, at superficial level.

; myMax(a,b) = 
; = a , if b is not a number
; = b , if a is not a number
; = a , if a > b
; = b , otherwise


(defun myMax (a b)
  (cond
    ((not (numberp a)) b)
    ((not (numberp b)) a)
    ((> a b) a)
    (t b)
  )
)


; maxForList (l1l2...ln) = 
; = NIL , if n = 0
; = myMax(l1, maxForList(l2...ln)) , otherwise


(defun maxForList(l)
  (cond
    ((null l) nil)
    (t (myMax (car l) (maxForList (cdr l))))
  )
)



//////////////////////////////5



; a) Write twice the n-th element of a linear list. Example: for (10 20 30 40 50) and n=3 will produce (10
;    20 30 30 40 50).


; twiceNthElem(l1l2...lm, n, pos) = 
; = nil , if m = 0
; = {l1} U {l1} U twiceNthElem(l2...lm, n, pos + 1) , if n = pos
; = {l1} U twiceNthElem(l2...lm, n, pos + 1) , otherwise


(defun twiceNthElem(l n pos)
  (cond
    ((null l) nil)
    ((equal n pos) (cons (car l) (cons (car l) (twiceNthElem (cdr l) n (+ 1 pos)))))
    (t (cons (car l) (twiceNthElem (cdr l) n (+ 1 pos))))
  )
)

(defun mainA(l n)
  (twiceNthElem l n 0)
)

; b) Write a function to return an association list with the two lists given as parameters.
;    Example: (A B C) (X Y Z) --> ((A.X) (B.Y) (C.Z)).


; myAppend(l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = {l1} U myAppend(l2...ln, p1p2...pm), otherwise

(defun myAppend(l p)
  (cond
    ((null l) p)
    (t (cons (car l) (myAppend (cdr l) p)))
  )
)

; association(l1l2...ln, p1p2...pm) = 
; = nil, if n = 0 and m = 0
; = myAppend(association(nil, p2...pm), list({nil} U {p1})), if n = 0
; = myAppend(association(l2...ln, nil), list({l1} u {nil})), if m = 0
; = myAppend(association(l2...ln, p2...pm), list({l1} U {p1})), otherwise


(defun association(l p)
  (cond
    ((and (null l) (null p)) nil)
    ((null l) (myAppend (list (cons nil (car p))) (association nil (cdr p) )))
    ((null p) (myAppend (list (cons (car l) nil)) (association (cdr l) nil )))
    (t (myAppend (list (cons (car l) (car p))) (association (cdr l) (cdr p) )))
  )
)


; c) Write a function to determine the number of all sublists of a given list, on any level.
;    A sublist is either the list itself, or any element that is a list, at any level. Example:
;    (1 2 (3 (4 5) (6 7)) 8 (9 10)) => 5 lists:
;    (list itself, (3 ...), (4 5), (6 7), (9 10))


; countLists(l1l2...ln) =
; = 0 , if n = 0
; = 1 + countLists(l1) + countLists(l2...ln) , if l1 is a list
; = countLists(l2...ln) , otherwise

(defun countLists(l)
  (cond
    ((null l) 1)
    ((listp (car l)) (+ (countLists (car l)) (countLists (cdr l))))
    (t (countLists (cdr l)))
  )
)


;d) Write a function to return the number of all numerical atoms in a list at superficial level.


; getAllNumericalAtoms(l1l2...ln) = 
; = 0 , if n = 0
; = 1 + getAllNumbericalAtoms(l2...ln) , if l1 is a number
; = getAllNumericalAtoms(l2...ln) , otherwise

(defun getAllNumericalAtoms (l)
  (cond
    ((null l) 0)
    ((numberp (car l)) (+ 1 (getAllNumericalAtoms (cdr l))))
    (t (getAllNumericalAtoms (cdr l)))
  )
)


///////////////////////////////////6



;a) Write a function to test whether a list is linear.

; checkLinear(l1l2...ln) = 
; = true, if n = 0
; = false, if l1 is a list
; = checkLinear(l2...ln), otherwise


(defun checkLinear(l)
  (cond
    ((null l) t)
    ((listp (car l)) nil)
    (t (checkLinear (cdr l)))
  )
)

;b) Write a function to replace the first occurence of an element E in a given list with an other element O.

; replaceFirstOcc(l1l2...ln, elem, newElem) = 
; = nil , if n = 0
; = {newElem} U (l2...ln), if elem = l1
; = {l1} U replaceFirstOcc(l2...ln), otherwise

(defun replaceFirstOcc(l elem newElem)
  (cond
    ((null l) nil)
    ((equal elem (car l)) (cons newElem (cdr l)))
    (t (cons (car l) (replaceFirstOcc (cdr l) elem newElem)))
  )
)

;--- the function from above works only for a linear list


; searchElement(l1l2...ln, elem) = 
; = nil (false) , if n = 0
; = true , if l1 = elem
; = searchElement(l2...ln), otherwise

(defun searchElement(l elem)
  (cond
    ((null l) nil)
    ((equal (car l) elem) t)
    (t (searchElement (cdr l) elem))
  )
)


; firstOccReplace(l1l2...ln, elem, newElem) = 
; = nil , if n = 0
; = {newElem} U (l2...ln) , if elem = l1
; = firstOccReplace(l1, elem, newElem) U (l2...ln), if l1 is a list and searchElement(l1, elem) = true
; = {l1} U firstOccReplace(l2...ln, elem, newElem), otherwise


(defun firstOccReplace(l elem newElem)
  (cond
    ((null l) nil)
    ((equal (car l) elem) (cons newElem (cdr l)))
    ((and (listp (car l)) (searchElement (car l) elem)) (cons (firstOccReplace (car l) elem newElem) (cdr l)))
    (t (cons (car l) (firstOccReplace (cdr l) elem newElem)))
  )
)

;--- the funtion above works for a non linear list


; c) Write a function to replace each sublist of a list with its last element.
;    A sublist is an element from the first level, which is a list.
;    Example: (a (b c) (d (e (f)))) ==> (a c (e (f))) ==> (a c (f)) ==> (a c f)
;    (a (b c) (d ((e) f))) ==> (a c ((e) f)) ==> (a c f)


; myAppend(l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = {l1} U myAppend(l2...ln, p1p2...pm), otherwise

(defun myAppend(l p)
  (cond
    ((null l) p)
    (t (cons (car l) (myAppend (cdr l) p)))
  )
)

; myReverse(l1l2...ln) = 
; = nil , if n = 0
; = myAppend(myReverse(l2...ln), list(myReverse(l1))) , if l1 is a list
; = myAppend(myReverse(l2...ln), list(l1)) , otherwise

(defun myReverse (l)
  (cond
    ((null l) nil)
    ((listp (car l)) (myAppend (myReverse (cdr l)) (list (myReverse (car l)))))
    (t (myAppend (myReverse (cdr l)) (list (car l))))
  )
)

;-- the function above for reverse works for non-linear lists as well


; my_reverse(l1l2...ln) = 
; = nil , if n = 0
; = myAppend(my_reverse(l2...ln) , list(l1)) , otherwise


(defun my_reverse(l)
  (cond
    ((null l) nil)
    (t (myAppend (my_reverse (cdr l)) (list (car l))))
  )
)

(defun last_element (l)
	(if (listp l) 
        (last_element (car (my_reverse l)))
        l
    )
)

; myReduce(l1l2...ln) = 
; = nil , if n = 0
; = last_element(l1) U myReduce(l2...ln), if l1 is a list
; = {l1} U myReduce(l2...ln) , otherwise


(defun myReduce (l)
  (cond
    ((null l) nil)
    ((listp l) (cons (last_element (car l)) (myReduce (cdr l))))
    (t (cons (car l) (myReduce (cdr l))))
  )
)


; d) Write a function to merge two sorted lists without keeping double values.

; myMerge(l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = {l1} U myMerge(l2...ln, p1p2...pm) , if l1 < p1
; = {p1} U myMerge(l1l2...ln, p2...pm) , if l1 > p1
; = {l1} U myMerge(l2...ln, p2...pm) , if l1 = p1


(defun myMerge (l p)
  (cond
    ((null l) p)
    ((null p) l)
    ((< (car l) (car p)) (cons (car l) (myMerge (cdr l) p)))
    ((> (car l) (car p)) (cons (car p) (myMerge l (cdr p))))
    ((= (car l) (car p)) (cons (car l) (myMerge (cdr l) (cdr p))))
  )
)



//////////////////////////////7



;a) Write a function to eliminate the n-th element of a linear list.

; eliminateNthElem(l1l2...ln, n, pos) =
; = nil , if n = 0
; = eliminateNthElem(l2...ln, n, pos + 1), if  n = pos
; = {l1} U eliminateNthElem(l2...ln, n, pos + 1), otherwise


(defun eliminateNthElem(l n pos)
  (cond
    ((null l) nil)
    ((equal n pos) (eliminateNthElem (cdr l) n (+ 1 pos)))
    (t (cons (car l) (eliminateNthElem (cdr l) n (+ 1 pos))))
  )
)


(defun mainA(l n)
  (eliminateNthElem l n 0)
)


; b) Write a function to determine the successor of a number represented digit by digit as a list, without
;    transforming the representation of the number from list to number. Example: (1 9 3 5 9 9) --> (1 9 3 6 0
;    0)


; carry(a b c) = 
; = 1 , if a + b + c > 9
; = 0 , if a + b + c <= 9

(defun carry(a b c)
  (cond
    (( > (+(+ a b) c) 9) 1)
    (t 0)
  )
)

; digit(a b c) = 
; (a + b + c) mod 10 , if a + b + c > 9
; a + b + c , if a + b + c <=9

(defun digit(a b c)
  (cond
    (( > (+ (+ a b) c) 9) (mod (+ (+ a b) c) 10))
    (t (+ (+ a b) c))
  )
)

; myAppend(l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = {l1} U myAppend(l2...ln, p1p2...pm) , otherwise

(defun myAppend(l p)
  (cond
    ((null l) p)
    (t (cons (car l) (myAppend (cdr l) p)))
  )
)

; myReverse(l1l2...ln) = 
; = nil , if n = 0
; = myAppend(myReverse(l2...ln), list(myReverse(l1))), if l1 is a list
; = myAppend(myReverse(l2...ln), list(l1)), otherwise


(defun myReverse(l)
  (cond
    ((null l) nil)
    ((listp (car l)) (myAppend (myReverse (cdr l)) (list (myReverse (car l)))))
    (t (myAppend (myReverse (cdr l)) (list (car l))))
  )
)

; myAdd(l1l2...ln, p1p2...pm, c, r) = 
; = c , if n = 0 and c = 1
; = nil , if n = 0 and c = 0
; = myAdd(l2...ln, nil, carry(l1, 0, c), {digit(l1, 0, c)} U r) , if m = 0
; = myAdd(nil, p2...pn, carry(0, p1, c), {digit(0, p1, c)} U r) , if n = 0
; = myAdd(l2...ln, p2...pn, carry(l1, p1, c), {digit(l1, p1, c)} U r) , otherwise

(defun myAdd(l p c r)
  (cond 
    ((and (and (null l) (null p)) (equal c 1)) (cons c r))
    ((and (and (null l) (null p)) (equal c 0)) r)
    ((null p) (myAdd (cdr l) nil (carry (car l) 0 c) (cons (digit (car l) 0 c) r)))
    ((null l) (myAdd nil (cdr p) (carry 0 (car p) c) (cons (digit 0 (car p) c) r)))
    (t (myAdd (cdr l) (cdr p) (carry (car l) (car p) c) (cons (digit (car l) (car p) c) r)))
  )
)

(defun mySuccessor(l)
  (myAdd (myReverse l) (list 1) 0 (list ))
)

; c) Write a function to return the set of all the atoms of a list.
;    Exemplu: (1 (2 (1 3 (2 4) 3) 1) (1 4)) ==> (1 2 3 4)


; linearizeList(l1l2...ln) = 
; = nil, if n = 0
; = myAppend(linearizeList(l1), (linearizeList(l2...ln))), if l1 is a list
; = {l1} U linearizeList(l2...ln) , if l1 is a number
; = linearizeList(l2...ln) , otherwise


(defun linearizeList(l)
  (cond
    ((null l) nil)
    ((listp (car l)) (myAppend (linearizeList (car l)) (linearizeList (cdr l))))
    ((atom (car l)) (cons (car l) (linearizeList (cdr l))))
    (t (linearizeList (cdr l)))
  )
)

; checkExistence(l1l2...ln, elem) = 
; = nil (false), if n = 0
; = true , if l1 = elem
; = checkExistence(l2...ln, elem) , otherwise

(defun checkExistence(l elem)
  (cond
    ((null l) nil)
    ((equal (car l) elem) t)
    (t (checkExistence (cdr l) elem))
  )
)

; toSet(l1l2...ln, r) = 
; = r, if n = 0
; = toSet(l2...ln, r) , if checkExistence(r, l1) = true
; = toSet(l2...ln, {l1} U r) , otherwise

(defun toSet(l r)
  (cond
    ((null l) r)
    ((checkExistence r (car l)) (toSet (cdr l) r))
    (t (toSet (cdr l) (myAppend r (list (car l)))))
  )
)

(defun mainC (l)
  (toSet (linearizeList l) (list))
)

; d) Write a function to test whether a linear list is a set.

; checkSet(l1l2...ln, r) = 
; = true, if n = 0
; = false, if checkExistence(r, l1) = true
; = checkSet(l2...ln, {l1} U r) , otherwise


(defun checkSet(l r)
  (cond
    ((null l) t)
    ((checkExistence r (car l)) nil)
    (t (checkSet (cdr l) (myAppend r (list (car l)))))
  )
)


///////////////////////////////////8


;a) Write a function to return the difference of two sets.

; myAppend(l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = {l1} U myAppend(l2...ln, p1p2...pm) , otherwise

(defun myAppend (l p)
  (cond
    ((null l) p)
    (t (cons (car l) (myAppend (cdr l) p)))
  )
)

; checkExistence(l1l2...ln, elem) = 
; = false (nil) , if n = 0
; = true , if l1 = elem
; = checkExistence(l2...ln, elem) , otherwise

(defun checkExistence(l elem)
  (cond
    ((null l) nil)
    ((equal (car l) elem) t)
    (t (checkExistence (cdr l) elem))
  )
)

; diffSets(l1l2...ln, p1p2...pm, r) = 
; = p1p2...pm, if n = 0
; = diffSets(l2...ln, p1p2...pm, r) , if checkExistence(p1p2...pm, l1)
; = diffSets(l2...ln, p1p2...pm, r U {l1}) , otherwise


(defun diffSets(l p r)
  (cond
    ((null l) r)
    ((checkExistence p (car l)) (diffSets (cdr l) p r))
    (t (diffSets (cdr l) p (myAppend r (list (car l)))))
  )
)


(defun mainA(l p)
  (myAppend (diffSets l p (list )) (diffSets p l (list )))
)


;b) Write a function to reverse a list with its all sublists, on all levels.

; myReverse(l1l2...ln) = 
; = nil , if n = 0
; = myAppend(myReverse(l2...ln), list(myReverse(l1))), if l1 is a list
; = myAppend(myReverse(l2...ln), list(l1)), otherwise


(defun myReverse(l)
  (cond
    ((null l) nil)
    ((listp (car l)) (myAppend (myReverse (cdr l)) (list (myReverse (car l)))))
    (t (myAppend (myReverse (cdr l)) (list (car l))))
  )
)


; c) Write a function to return the list of the first elements of all list elements of a given list with an odd
;    number of elements at superficial level. Example:
;    (1 2 (3 (4 5) (6 7)) 8 (9 10 11)) => (1 3 9).


; oddNrOfElems(l1l2...ln, c) =
; = true , if n = 0 and c % 2 = 1
; = false (nil) , if n = 0 and c % 2 = 0
; = oddNrOfElems(l2...ln, c + 1) , otherwise

(defun oddNrOfElems(l c)
  (cond
    ((and (null l) (equal 1 (mod c 2))) t)
    ((and (null l) (equal 0 (mod c 2))) nil)
    (t (oddNrOfElems (cdr l) (+ 1 c)))
  )
)

(defun checkOdd(l)
  (oddNrOfElems l 0)
)

; firstElem(l1l2...ln, f) = 
; = nil , if n = 0
; = myAppend(firstElem(l1, 0), firstElem(l2...ln, f)) , if l1 is a list
; = {l1} U firstElem(l2...ln, 1) , if checkOdd(l1l2...ln) is true and f = 0
; = firstElem(l2...ln, 1) , otherwise

(defun firstElem(l f)
  (cond
    ((null l) nil)
    ((listp (car l)) (myAppend (firstElem (car l) 0) (firstElem (cdr l) f)))
    ((and (checkOdd l) (= f 0)) (cons (car l) (firstElem (cdr l) 1)))
    (t (firstElem(cdr l) 1))
  )
)

(defun mainC(l)
  (firstElem l 0)
)


; d) Write a function to return the sum of all numerical atoms in a list at superficial level.

; sum(l1l2...ln) = 
; = 0 , if n = 0
; = l1 + sum(l2...ln), if l1 is a number
; = sum(l2...ln), otherwise


(defun sum(l)
  (cond
    ((null l) 0)
    ((numberp (car l)) (+ (car l) (sum (cdr l))))
    (t (sum (cdr l)))
  )
)


//////////////////////////9



;a) Write a function that merges two sorted linear lists and keeps double values.
;Mathematical model
;mymerge(l1l2...ln,k1k2...km)=
;{ k1k2...km, if n = 0
;{ l1l2...ln, if m = 0
;{ l1 U mymerge(l2...ln, k1k2...km) , if l1 <= k1
;{ k1 U mymerge(l1l2...ln, k2...km) , if k1 < l1 (otherwise case)

(defun mymerge(l k)
  (cond
    ((null l) k)
    ((null k) l)
    ((<=(car l)(car k)) (cons (car l) (mymerge (cdr l) k) ))
    (t (cons (car k) (mymerge l (cdr k))))
  )
)


;b)Write a function to replace an element E by all elements of a list L1 at all levels of a given list L. 


;myAppend(l1l2...ln,k1k2...km) = 
; k1k2...km, if n = 0
; l1 U myAppend(l2...ln, k1k2...km), otherwise

(defun myAppend (L1 L2)
  (cond
    ((null L1) L2)
    (T (cons (car L1) (myAppend (cdr L1) L2)))
  )
)


;replaceList (E, R, l1l2..ln) = {
; (), if n = 0
; {replace(E, R, l1)} U replace(E, R, l2..ln), if l1 is a list
; R U replace(E, R, l2..ln), if E = l1
; {l1} U replace(E, R, l2..ln), otherwise

(defun replaceList (E R L)
    (cond
        ((null L) ())
        ((listp (car L)) (cons (replaceList E R (car L)) (replaceList E R (cdr L))))
        ((equal E (car L)) (myAppend R (replaceList E R (cdr L))))
        (t (cons (car L) (replaceList E R (cdr L))))
    )
)


; (replaceList 3 (list ) (list 3 (list 3 4) (list 3) (list 1 3 4 (list 5 3 3) (list 4 5 6))))
; (replaceList 1 (list 5 6 7) (list 1 (list 2 2 (list 1 (list 5 1))) (list 1 3 4 5)))

;c)  Write  a  function  to  determines  the  sum  of  two  numbers  in  list  representation,
;    and  returns  the corresponding  decimal  number,  without  transforming  the  representation
;    of  the  number  from  list  to number.


; myAppend(l1l2...ln, k1k2...km) = 
; = k1k2...km, if n = 0
; = l1 U myAppend(l2...ln, k1k2...km), otherwise

(defun myAppend (L1 L2)
  (cond
    ((null L1) L2)
    (T (cons (car L1) (myAppend (cdr L1) L2)))
  )
)


; myReverse(l1l2...ln) = 
; = (), if n = 0
; = myAppend( myReverse(l2...ln), list (myReverse(l1)))  , if l1 is a list
; = myAppend( myReverse(l2...ln), list(l1)), otherwise


(defun myReverse (l)
    (cond
        ((null l) nil)
        ((listp (car l)) (myAppend (myReverse (cdr l)) (list (myReverse (car l)))))
        (T (myAppend (myReverse (cdr l)) (list (car l))))
    )
)

; carry(e1, e2, c) = 
; = 1, if e1 + e2 + c > 9
; = 0, otherwise

(defun carry (e1 e2 c)
  (cond
    ((< 9 (+ c(+ e1 e2))) 1)
    (t 0)
  )
)


; digit(e1, e2, c) = 
; = e1 + e2 + c mod 10, if e1 + e2 + c > 9
; = e1 + e2 + c, otherwise

(defun digit (e1 e2 c)
  (cond
    ((< 9 (+ c(+ e1 e2))) (mod (+ c(+ e1 e2)) 10))
    (t (+ c (+ e1 e2)))
  )
) 
    
; sumLists(l1l2...ln, k1k2...km, c, r) = 
; = r , if n = 0 and m = 0 and c = 0
; = {c} U r , if n = 0 and m = 0 and c != 0
; = sumLists(l2...ln, k, carry(l1, 0, c), {digit(l1, 0, c)} U r) , if m = 0
; = sumLists(l, k2...km, carry(0, k1, c), {digit(0, k1, c)} U r) , if n = 0
; = sumLists(l2...ln, k2...km, carry(l1, k1, c), {digit(l1, k1, c)} U r) , otherwise


(defun sumLists (l k c r)
  (cond
    ((and (null l)(null k)(= 0 c)) r)
    ; if we reach this case it means both lists are empty,
    ; we no longer have a cary, so we simply return the result
    ((and (null l)(null k)(/= 0 c)) (cons c r))
    ; if we reach this case it means both lists are empty, but we still have a carry so which means
    ; we need to add the carry to the result ( for example we had the numbers 9 and 1
    ; after we add them we obtain both lists empty, in the result we have a 0, but we
    ; still neet to add that 1
    ((null k) (sumLists (cdr l) k (carry (car l) 0 c) (cons (digit (car l) 0 c) r)))
    ; if we reach this case, it means the second number doesn't have digits anymore
    ; so we simply add the rest of the digits of the first number to the result
    ((null l) (sumLists l (cdr k) (carry 0 (car k) c) (cons (digit 0 (car k) c) r)))
    ; if we reach this case, it means the first number doesn't have digits anymote
    ; so we simply add the rest of the digits of the second number to the result
    (t (sumLists (cdr l) (cdr k) (carry (car l) (car k) c) (cons (digit (car l) (car k) c) r)))
    ; if we reach this case, it means both numbers still have digits so we add them in order to compute the result
  )
) 

(defun main (l k)
  (cond
    (t (sumLists (myReverse l) (myReverse k) 0 ()))
  )
)


;With this function we compute the gcd of two numbers

; myGCD(a b) = 
; = nil , if a is not a number and b is not a number
; = b , if a is not a number
; = a , if b is not a number
; = b , if a = 0
; = myGCD(b%a, a) , otherwise

(defun myGCD (a b)
  (cond
    ((and (not (numberp a)) (not (numberp b))) nil)
    ((not (numberp a)) b)
    ((not (numberp b)) a)
    ((= a 0) b)
    (t (myGCD (mod b a) a))
  )
)

; With this function we check if in our list we have at least one number, so we return a number greater than 0
; if we have at least a number and 0 otherwise

; lookForNumbers(l1l2...ln) = 
; = 0 , if n = 0
; = 1 , if l1 is a number
; = lookForNumbers(l1) + lookForNumbers(l2...ln) , if l1 is a list
; = lookForNumbers(l2...ln) , otherwise

(defun lookForNumbers (l)
  (cond
    ((null l) 0)
    ((numberp (car l)) 1)
    ((listp (car l)) (+ (lookForNumbers (car l)) (lookForNumbers (cdr l))))
    (t (lookForNumbers (cdr l)))
  )
)

; With this function we compute the gcd for all the numbers from a list

; gcdList(l1l2...ln) = 
; = l1 , if n = 1 and l1 is an atom
; = myGCD(gcdList(l1), (gcdList(l2...ln))) , if l1 is a list
; = myGCD(l1 , gcdList(l2...ln)) , otherwise

(defun gcdList (l)
  (cond
    ((and (atom (car l)) (null (cdr l))) (car l))
    ((listp (car l)) (myGCD (gcdList (car l)) (gcdList (cdr l)) ) )
    (t (myGCD (car l) (gcdList(cdr l)) ) )
  )
)

; With this function first we check if we have in our list any numbers, if we don't we simply return 0
; if we have at least a number, we call the function gcdList in order to find the gcd for all the elements
; of a list

; main(l1l2...ln) = 
; = 0 , if lookForNumbers(l1l2...ln) = 0
; = gcdList(l1l2...ln) , otherwise

(defun mainD (l)
  (cond
    ((= (lookForNumbers l) 0) 0)
    (t (gcdList l)) 
  )
)


; (mainD (list 1000 200 (list "A" ) (list 500) (list 300 (list 20 360 "A")) (list "A")))






////////////////////////////10



;a) Write a function to return the product of all the numerical atoms from a list, at superficial level.

; myProduct(l1l2...ln) = 
; = 1, if n = 0
; = l1 * myProduct(l2...ln) , if l1 is a number
; = myProduct(l2...ln) , otherwise


(defun myProduct (l)
  (cond
    ((null l) 1)
    ((numberp (car l)) (* (car l) (myProduct (cdr l))))
    (t (myProduct (cdr l)))
  )
)

;b) Write a function to replace the first occurence of an element E in a given list with an other element O.

; myAppend(l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = l1 U myAppend(l2...ln, p1p2...pm) , otherwise

(defun myAppend (l p)
  (cond
    ((null l) p)
    (t (cons (car l) (myAppend (cdr l) p)))
  )
)

; checkExistence(l1l2...ln, elem) = 
; = false , if n = 0
; = true , if l1 = elem
; = checkExistence(l2...ln, elem)

(defun checkExistence(l elem)
  (cond
    ((null l) nil)
    ((equal (car l) elem) t)
    (t (checkExistence (cdr l) elem))
  )
)

; replaceFirstOcc(l1l2...ln, elem, newElem) = 
; = nil , if n = 0
; = myAppend(list(replaceFirstOcc(l1, elem, newElem)), l2...ln), if l1 is a list and checkExistence(l1, elem) = true
; = newElem U l2...ln , if l1 = elem
; = replaceFirstOcc(l2...ln, elem, newElem) , otherwise


(defun replaceFirstOcc(l elem newElem)
  (cond
    ((null l) nil)
    ((and (listp (car l)) (checkExistence (car l) elem)) (myAppend (list(replaceFirstOcc (car l) elem newElem)) (cdr l)))
    ((equal (car l) elem) (cons newElem (cdr l)))
    (t (replaceFirstOcc (cdr l) elem newElem))
  )
)


; d) Write a function to produce the list of pairs (atom n), where atom appears for n times in the parameter
;    list. Example:
;    (A B A B A C A) --> ((A 4) (B 2) (C 1)).


; count(l1l2...ln, elem) = 
; = 0 , if n = 0
; = count(l1, elem) + count(l2...ln, elem) , if l1 is a list
; = 1 + count(l2...ln, elem) , if l1 = elem
; = count(l2...ln, elem), otherwise


(defun myCount(l elem)
  (cond
    ((null l) 0)
    ((listp (car l)) (+ (myCount (car l) elem) (myCount (cdr l) elem)))
    ((equal (car l) elem) (+ 1 (myCount (cdr l) elem)))
    (t (myCount (cdr l) elem))
  )
)

; removeElem(l1l2...ln, elem) = 
; = nil , if n = 0
; = myAppend(list(removeElem(l1, elem)), removeElem(l2...ln, elem)), if l1 is a list
; = removeElem(l2, elem) , if l1 = elem
; = l1 U removeElem(l2, elem) , otherwise

(defun removeElem(l elem)
  (cond
    ((null l) nil)
    ((listp (car l)) (myAppend (list (removeElem (car l) elem)) (removeElem (cdr l) elem)))
    ((equal (car l) elem) (removeElem (cdr l) elem))
    (t (cons (car l) (removeElem (cdr l) elem)))
  )
)

; myPairs(l1l2...ln, r1r2...rm) = 
; = r1r2...rm, if n = 0
; = myAppend(


; -- at a superficial level
(defun myPairs (l)
  (cond
    ((null l) nil)
    (t (cons (list (car l) (myCount l (car l))) (myPairs (removeElem (cdr l) (car l)))))
  )
)

; -- in the sublists as well
; -- didn't manage to do that



///////////////////////////11



;a) Determine the least common multiple of the numerical values of a nonlinear list.

; myGCD(a, b) = 
; = a , if b is not a number
; = b , if a is not a number
; = a , if b = 0
; = myGCD(b, a%b) , otherwise

(defun myGCD(a b)
  (cond
    ((not (numberp b)) a)
    ((not (numberp a)) b)
    ((equal 0 b) a)
    (t (myGCD b (mod a b)))
  )
)

; myLCM(a, b) = 
; = a , if b is not a number
; = b , if a is not a number
; = a * b / myGCD(a, b) , otherwise


(defun myLCM(a b)
  (cond
    ((not (numberp b)) a)
    ((not (numberp a)) b)
    (t (/ (* a b) (myGCD a b)))
  )
)


; lookForNumbers(l1l2...ln) = 
; nil , if n = 0
; lookForNumbers(l1) or lookForNumbers(l2...ln) , if l1 is a list
; true , if l1 is a number
; lookForNumbers(l2...ln) , otherwise


(defun lookForNumbers (l)
  (cond
    ((null l) nil)
    ((listp (car l)) (or (lookForNumbers (car l)) (lookForNumbers (cdr l))))
    ((numberp (car l)) t)
    (t (lookForNumbers (cdr l)))
  )
)

; lcmForList(l1l2...ln) = 
; = l1 , if n = 1
; = myLCM(lcmForList(l1) , lcmForList(l2...ln)) , if l1 is a list
; = myLCM(l1, lcmForList(l2...ln) , otherwise  


(defun lcmForList(l)
  (cond
    ((null (cdr l)) (car l))
    ((listp (car l)) (myLCM (lcmForList (car l)) (lcmForList (cdr l))))
    (t (myLCM (car l) (lcmForList (cdr l))))
  )
)

; First we check if we have any numbers in the list, if we don't have any numbers , we return 1, otherwise we go
; look for the least common multiple in the entire list on each level
(defun mainA(l)
  (cond
    ((lookForNumbers l) (lcmForList l))
    (t 1)
  )
)



; b) Write a function to test if a linear list of numbers has a "mountain" aspect (a list has a "mountain"
;    aspect if the items increase to a certain point and then decreases.
;    Eg. (10 18 29 17 11 10). The list must have at least 3 atoms to fullfil this criteria.

; f = 0 for an increasing sequence
; f = 1 for a decreasing sequence
; mountain(l1l2...ln, f) = 
; = true , if n <= 1 and f = 1
; = mountain(l2...ln, 0), if l1 <= l2 and f = 0
; = mountain(l2...ln, 1), if l1 >= l2 and f = 0
; = mountain(l2...ln, 1), if l1 >= l2 and f = 1
; = false , otherwise


(defun mountain(l f)
  (cond
    ((and (null (cdr l)) (= f 1)) t)
    ((and (<= (car l) (cadr l)) (= f 0)) (mountain (cdr l) 0))
    ((and (>= (car l) (cadr l)) (= f 0)) (mountain (cdr l) 1))
    ((and (>= (car l) (cadr l)) (= f 1)) (mountain (cdr l) 1))
    (t nil)
  )
)

; mainB(l1l2...ln) = 
; = nil (false) , if n = 0
; = nil (false) , if n = 1
; = nil (false) , if n = 2
; = mountain(l1l2...ln, 0) , otherwise

;In order to check for the mountain aspect, our list need to have at least 3 elements
(defun mainB(l)
  (cond
    ((null l) nil)
    ((null (cadr l)) nil)
    ((null (caddr l)) nil)
    (t (mountain l 0))
  )
)


; c) Remove all occurrences of a maximum numerical element from a nonlinear list.

; myMax(a, b) = 
; = a , if b is not a number
; = b , if a is not a number
; = a , if a > b
; = b , otherwise

(defun myMax(a b)
  (cond
    ((not (numberp b)) a)
    ((not (numberp a)) b)
    (( > a b) a)
    (t b)
  )
)

; maxForList(l1l2...ln) = 
; = nil , if n = 0
; = myMax(maxForList(l1), maxForList(l2...ln)) , if l1 is a list
; = myMax(l1, maxForList(l2...ln)) , otherwise


(defun maxForList(l)
  (cond
    ((null l) nil)
    ((listp (car l)) (myMax (maxForList (car l)) (maxForList (cdr l))))
    (t (myMax (car l) (maxForList (cdr l))))
  )
)


; myAppend (l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = {l1} U myAppend(l2...ln, p1p2...pm) , otherwise

(defun myAppend (l p)
  (cond
    ((null l) p)
    (t (cons (car l) (myAppend (cdr l) p)))
  )
)


; removeElem(l1l2...ln, elem) = 
; = nil , if n = 0
; = removeElem(l1, elem) U removeElem(l2...ln, elem) , if l1 is a list
; = removeElem(l2...ln, elem) , if l1 = elem
; = {l1} U removeElem(l2...ln, elem) , otherwise

(defun removeElem(l elem)
  (cond
    ((null l) nil)
    ((listp (car l)) (cons (removeElem (car l) elem) (removeElem (cdr l) elem)))
    ((equal (car l) elem) (removeElem (cdr l) elem))
    (t (cons (car l) (removeElem (cdr l) elem)))
  )
)


(defun mainC (l)
  (removeElem l (maxForList l))
)

;d) Write a function which returns the product of numerical even atoms from a list, to any level.


; isEven(a) = 
; = t , if a % 2 = 1
; = nil (false) , otherwise


(defun isEven (a)
  (cond
    ((equal 0 (mod a 2)) t)
    (t nil)
  )
)

; productEvenNumbers(l1l2...ln) = 
; = 1, if n = 0
; = productEvenNumbers(l1) * productEvenNumbers(l2...ln) , if l1 is a list
; = l1 * productEvenNumbers(l2...ln) , if l1 is a number and is even
; = productEvenNumbers(l2...ln) , otherwise


(defun productEvenNumbers(l)
  (cond
    ((null l) 1)
    ((listp (car l)) (* (productEvenNumbers (car l)) (productEvenNumbers (cdr l))))
    ((and (numberp (car l)) (isEven (car l))) (* (car l) (productEvenNumbers (cdr l))))
    (t (productEvenNumbers (cdr l)))
  )
)


; First we check if we have any numbers in the list, if we have then we try to compute the product
; Otherwise we simply return 0
(defun mainD(l)
  (cond
    ((lookForNumbers l) (productEvenNumbers l))
    (t 0)
  )
)



//////////////////12



;a) Write a function to return the dot product of two vectors. https://en.wikipedia.org/wiki/Dot_product 

; dotProduct(l1l2...ln, k1k2...km) = 
; = 0 , if n = 0
; = l1*l2 + dotProduct(l2...ln, k2...km) , otherwise

(defun dotProduct(l k)
  (cond
    ((null l) 0)
    (t (+ (* (car l) (car k)) (dotProduct (cdr l) (cdr k))))
  )
)


;b) Write a function to return the maximum value of all the numerical atoms of a list, at any level.

; lookForNumbers(l1l2...ln, c) = 
; = 0 , if n = 0 and c = 0
; = 1 , if n = 0 and c > 0
; = lookForNumbers(l2...ln, c + 1) , if l1 is a number
; = lookForNumbers(l1, c) + lookForNumbers(l2...ln, c), if l1 is a list
; = lookForNumbers(l2...ln, c) , otherwise


(defun lookForNumbers(l c)
  (cond
    ((and (null l)(= c 0)) 0)
    ((and (null l)(> c 0)) 1)
    ((numberp (car l) ) (lookForNumbers (cdr l) (+ 1 c)))
    ((listp (car l)) (+ (lookForNumbers (car l) c) (lookForNumbers (cdr l) c)))
    (t (lookForNumbers (cdr l) c))
  )
)


; myMax(a, b) = 
; = () , if a is not a number and b is not a number
; = b , if a is not a number
; = a , if b is not a number
; = a , if a > b
; = b , otherwise

(defun myMax(a b)
  (cond
    ((and (not (numberp a)) (not (numberp b))) nil)
    ((not (numberp a)) b)
    ((not (numberp b)) a)
    ((> a b) a)
    (t b)
  )
)  

; maxList(l1l2...ln) = 
; = l1 , if n = 1 and l1 is an atom
; = myMax(maxList(l1), maxList(l2...ln)) , if l1 is a list
; = myMax(l1, maxList(l2...ln) , otherwise

(defun maxList(l)
  (cond
    ((and (null (cdr l)) (atom (car l))) (car l))
    ((listp (car l)) (myMax (maxList (car l)) (maxList(cdr l))))
    (t (myMax (car l) (maxList (cdr l))))
  )
)


; main(l1l2...ln) = 
; 0 , if lookForNumbers = 0
; maxList(l1l2...ln) , otherwise

(defun main(l)
  (cond
    ((= (lookForNumbers l 0) 0) 0)
    (t (maxList l))
  )
) 


; c) All permutations to be replaced by: Write a function to compute the result of an arithmetic expression 
; memorised in preorder on a stack. Examples: 
;        (+ 1 3) ==> 4  (1 + 3) 
;        (+ * 2 4 3) ==> 11  [((2 * 4) + 3) 
;        (+ * 2 4 - 5 * 2 2) ==> 9  ((2 * 4) + (5 - (2 * 2)) 


; myAppend(l1l2...ln, k1k2...km) = 
; = k1k2...km, if n = 0
; = l1 U myAppend(l2...ln, k1k2...km), otherwise

(defun myAppend (L1 L2)
  (cond
    ((null L1) L2)
    (T (cons (car L1) (myAppend (cdr L1) L2)))
  )
)


; myReverse(l1l2...ln) = 
; = (), if n = 0
; = myAppend( myReverse(l2...ln), list (myReverse(l1)))  , if l1 is a list
; = myAppend( myReverse(l2...ln), list(l1)), otherwise

(defun myReverse (l)
    (cond
        ((null l) nil)
        ((listp (car l)) (myAppend (myReverse (cdr l)) (list (myReverse (car l)))))
        (T (myAppend (myReverse (cdr l)) (list (car l))))
    )
)


; evaluate(l1l2...ln, s1s2...sm) = 
; s1 , if n = 0
; evaluate(l2...ln, {l1} U s1s2...sm)  , if l1 is a number
; evaluate(l2...ln, {s1 * s2} U s3...sm) , if l1 = "*"
; evaluate(l2...ln, {s1 + s2} U s3...sm) , if l1 = "+"
; evaluate(l2...ln, {s1 / s2} U s3...sm) , if l1 = "/"
; evaluate(l2...ln, {s1 - s2} U s3...sm) , if l1 = "-"



(defun evaluate(l s)
  (cond
    ((null l) (car s))
    ((numberp (car l)) (evaluate (cdr l) (cons (car l) s)))
    ((string= "*" (car l)) (evaluate (cdr l) (cons (* (car s) (cadr s)) (cddr s))))
    ((string= "+" (car l)) (evaluate (cdr l) (cons (+ (car s) (cadr s)) (cddr s))))
    ((string= "/" (car l)) (evaluate (cdr l) (cons (floor (car s) (cadr s)) (cddr s))))
    (t (evaluate (cdr l) (cons (- (car s) (cadr s)) (cddr s))))
  )
)


; mainC(l1l2...ln) = 
; = evaluate(myReverse(l1l2...ln) ()) 

(defun mainC(l)
  (cond
    (t (evaluate (myReverse l) ()))
  )
)

; d)Write a function to return T if a list has an even number of elements on the first level, and NIL on the 
;   contrary case, without counting the elements of the list. 

; evenLength(l1l2...ln) =
; = true , if n = 0 
; = false , if n = 1
; = evenLength(l3...ln) , otherwise


(defun evenLength(l)
  (cond
    ((null l) T)
    ((null (cdr l)) nil)
    (t (evenLength (cddr l)))
  )
)


///////////////////////////////13


; a) A linear list is given. Eliminate from the list all elements from N to N steps, N-given.

; ----Here is solved the problem with the wrong understanding!!!
; removeFromNtoN(l1l2...ln, N, C1, C2) = 
; = nil , if n = 0
; = {l1} U removeFromNtoN(l2...ln, N, C1 + 1, C2), if C1 != N or C1 = C2 + 1= N
; = removeFromNtoN(l2...ln, N, C1, C2 + 1), if C2 != N + 1 and C1 = N

;(defun removeFromNtoN(l n c1 c2)
;  (cond
;    ((null l) nil)
;    ((or (not (equal c1 n)) (and (equal c1 (+ 1 c2)) (equal (+ 1 c2) n))) (cons (car l) (removeFromNtoN (cdr l) n (+ c1 1) c2)))
;    ((and (not (equal c2 (+ 1 n))) (equal c1 n)) (removeFromNtoN (cdr l) n c1 (+ c2 1)))
;  )
;)

;(defun mainA(l n)
;  (removeFromNtoN l n 0 0)
;)



; removeFromNtoN(l1l2...ln, n, k) = 
; = nil, if n = 0 
; = removeFromNtoN(l2...ln, n, n), if k = 1
; = {l1} U removeFromNtoN(l2...ln, n, k - 1) , otherwise

(defun removeFromNtoN(l n k)
  (cond 
    ((null l) nil)
    ((equal k 1) (removeFromNtoN (cdr l) n n))
    (t (cons (car l) (removeFromNtoN (cdr l) n (- k 1))))
  )
)

(defun mainA(l n)
  (removeFromNtoN l n n)
)


; b) Write a function to test if a linear list of integer numbers has a "valley" aspect (a list has a valley
;    aspect if the items decrease to a certain point and then increase. Eg. 10 8 6 17 19 20). A list must have
;    at least 3 elements to fullfill this condition.


; findLength(l1l2...ln) = 
; = 0 , if n = 0
; = 1 + findLength(l2...ln) , otherwise

(defun findLength(l)
  (cond
    ((null l) 0)
    (t (+ 1 (findLength (cdr l))))
  )
)


; valley(l1l2...ln, decreasing) = 
; = nil (false), if n = 1 and decreasing = true
; = true , if n = 1 and decreasing = false
; = nil (false) , if l1 > l2 and decreasing = false
; = valley(l2...ln, false), if l1 < l2 and decreasing = true
; = valley(l2...ln, decreasing), otherwise

(defun valley (l decreasing)
	(cond
		((= (findLength l) 1) (if decreasing nil T))
		((and (> (car l) (cadr l)) (not decreasing)) nil)
		((and (< (car l) (cadr l)) decreasing) (valley (cdr l) nil))
		(T (valley (cdr l) decreasing))
	)
)

(defun mainB(l)
  (cond
    ((null l) nil)
    ((null (cadr l)) nil)
    ((null (caddr l)) nil)
    ((< (car l) (cadr l)) nil)
    (t (valley l T))
  )
)


;c) Build a function that returns the minimum numeric atom from a list, at any level.

; myMin(a, b) = 
; = nil , if a is not a number and b is not a numbe
; = a , if b is not a numbe
; = b , if a is not a number
; = a , if a < b
; = b , otherwise

(defun myMin(a b)
  (cond
    ((and (not (numberp a)) (not (numberp b))) nil)
    ((not (numberp a)) b)
    ((not (numberp b)) a)
    ((< a b) a)
    (t b)
  )
)


; findMin(l1l2...ln) = 
; = l1 , if n = 1 and l1 is an atom
; = myMin(findMin(l1), findMin(l2...ln)) , if l1 is a list
; = myMin(l1, findMin(l2...ln)) , otherwise


(defun findMin(l)
  (cond
    ((and (null (cdr l)) (atom (car l))) (car l))
    ((listp (car l)) (myMin (findMin (car l)) (findMin (cdr l))))
    (t (myMin (car l) (findMin (cdr l))))
  )
)


//////////////////////////14



; a) Write a function to return the union of two sets.

; removeFirstOcc(l1l2...ln, elem) =
; = nil, if n = 0
; = l2...ln, if l1 = elem
; = {l1} U removeFirstOcc(l2...ln, elem) , otherwise

(defun removeFirstOcc(l elem)
  (cond
    ((null l) nil)
    ((equal (car l) elem) (cdr l))
    (t (cons (car l) (removeFirstOcc (cdr l) elem)))
  )
)

; unionSets(l1l2...ln, p1p2...pm) = 
; = nil if n = 0 and m = 0
; = l1l2...ln, if m = 0
; = p1p2...pm, if n = 0
; = {l1} U unionSets(l2...ln, removeFirstOcc(p1p2...pm, l1)) , otherwise

(defun unionSets(l1 l2)
  (cond
    ((and (null l1) (null l2)) nil)
    ((null l1) l2)
    ((null l2) l1)
    (t (cons (car l1) (unionSets (cdr l1) (removeFirstOcc l2 (car l1)))))
  )
)


;c) Write a function to sort a linear list with keeping the double values.

; insertOk(l1l2...ln, elem) = 
; = list(elem), if n = 0
; = {elem} U l1l2...ln, if elem < l1 
; = {l1} U insertOk(l2...ln, elem) , otherwise


(defun insertOk(l elem)
  (cond
    ((null l) (list elem))
    ((< elem (car l)) (cons elem l))
    (t (cons (car l) (insertOk (cdr l) elem)))
  )
)

; mySort(l1l2...ln) = 
; = nil , if n = 0
; = mySort(insertOk(l2...ln, l1)) , otherwise


(defun mySort(l)
  (cond
    ((null l) nil)
    (t (insertOk (mySort (cdr l)) (car l)))
  )
)

; d) Build a list which contains positions of a minimum numeric element from a given linear list.

; myMin(a, b) = 
; = nil , if a is not a number and b is not a number
; = a , if b is not a number
; = b , if a is not a number
; = a , if a < b
; = b , otherwise

(defun myMin(a b)
  (cond
    ((and (not (numberp a)) (not (numberp b))) nil)
    ((not (numberp a)) b)
    ((not (numberp b)) a)
    ((< a b) a)
    (t b)
  )
)


; minList(l1l2...ln) = 
; = l1 , is n = 1 and l1 is an atom
; = myMin(minList(l1), minList(l2...ln)), if l1 is a list; = myMin(l1, minList(l2...ln)), otherwise


(defun minList(l)
  (cond 
    ((and (null (cdr l)) (atom (car l))) (car l))
    ((listp (car l)) (myMin (minList (car l)) (minList (cdr l))))
    (t (myMin (car l) (minList (cdr l))))
  )
)


; minPos(l1l2...ln, min, pos) = 
; = nil, if n = 0
; = pos U minPos(l2...ln, min, pos + 1) , if l1 = min
; = minPos(l2...ln, min, pos + 1), otherwise


(defun minPos (l min pos)
  (cond
    ((null l) nil)
    ((equal (car l) min) (cons pos (minPos (cdr l) min (+ 1 pos))))
    (t (minPos (cdr l) min (+ 1 pos)))
  )
)

(defun mainD (l)
  (minPos l (minList l) 0)
)



////////////////////////15


; a) Write a function to insert an element E on the n-th position of a linear list.

; insertAtPos(l1l2...ln, pos, elem) = 
; = nil, if n = 0
; = {elem} U l1l2...ln, if pos = 0
; = {l1} U insertAtPos(l2...ln, pos - 1, elem) , otherwise

(defun insertAtPos(l pos elem)
  (cond
    ((null l) nil)
    ((equal pos 0 ) (cons elem l))
    (t (cons (car l) (insertAtPos (cdr l) (- pos 1) elem)))
  )
)

; c) Write a function to return the set of all sublists of a given linear list. Ex. For list ((1 2 3) ((4 5) 6)) =>
; ((1 2 3) (4 5) ((4 5) 6))

; myAppend(l1l2...ln, p1p2...pm) = 
; = p1p2...pm, if n = 0
; = {l1} U myAppend(l2...ln, p1p2...pm) , otherwise

(defun myAppend (l p)
  (cond
    ((null l) p)
    (t (cons (car l) (myAppend (cdr l) p)))
  )
)

; sublists(l1l2...ln) = 
; = nil, if n = 0
; = myAppend(list(l1), myAppend(sublists(l1), sublists(l2...ln))), if l1 is a list
; = sublists(l2...ln), otherwise

(defun sublists (l) 
    (cond
        ((null l) nil)
        ((listp (car l)) (myAppend (list (car l)) (myAppend (sublists (car l)) (sublists (cdr l)))))
        (t (sublists (cdr l)))
    )
)

; d) Write a function to test the equality of two sets, without using the difference of two sets.

; removeFirstOcc(l1l2...ln, elem) = 
; = nil, if n = 0
; = l2...ln, if elem = l1
; = {l1] U removeFirstOcc(l2...ln, elem), otherwise


(defun removeFirstOcc(l elem)
  (cond
    ((null l) nil)
    ((equal elem (car l)) (cdr l))
    (t (cons (car l) (removeFirstOcc (cdr l) elem)))
  )
)

; equalitySets(l1l2...ln, p1p2...pm) = 
; = true, if n = 0 and m = 0
; = false, if n = 0 or m = 0
; = equalitySets(l2...ln, removeFirstOcc(p1p2...pm, l1)), otherwise

(defun equalitySets(l p)
  (cond
    ((and (null l) (null p)) T)
    ((or (null l) (null p)) nil)
    (t (equalitySets (cdr l) (removeFirstOcc p (car l))))
  )
)










